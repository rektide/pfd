{"id":"pfd-99v","title":"SOCKET-DISCOVERY: Crate for Unix domain socket discovery","description":"Crate library for Unix domain socket discovery across multiple strategies.\n\nThis library provides flexible socket location finding for daemons:\n\n**Discovery Strategies:**\n- Local file mode: `./pfd.sock` or `.pfd.sock`\n- XDG runtime mode: `$XDG_RUNTIME_DIR/pfd.sock`\n- XDG-project mode: `$XDG_RUNTIME_DIR/pfd.\u003cproject-name\u003e.sock`\n\n**Features:**\n- Fallback strategy configuration\n- Atomic socket file creation\n- Socket file permission management\n- Project name extraction and validation\n- Cross-platform XDG path handling via `directories` crate\n\n**Usage:**\nDaemon creates socket with configured mode. Client searches through strategies in priority order to find active daemon.\n\nGoal: Reusable crate for any daemon that needs flexible Unix domain socket discovery.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-15T20:04:35.061084212-05:00","created_by":"rektide","updated_at":"2026-01-15T20:04:35.061084212-05:00"}
{"id":"pfd-9i9","title":"FD-TRANSFER: File descriptor transfer subsystem","description":"File descriptor transfer over Unix domain sockets using ancillary data.\n\nThis subsystem provides safe, ergonomic fd passing:\n\n**Components:**\n- Unix domain socket wrapper with ancillary data support\n- Send/receive multiple file descriptors atomically\n- Descriptor lifecycle and ownership management\n- Error handling for partial/failed transfers\n\n**API:**\n- `send_fds(\u0026socket, \u0026[FileDescriptor])` interface\n- `recv_fds(\u0026socket) -\u003e Result\u003cVec\u003cFileDescriptor\u003e\u003e`\n- Clear error types for debugging transfer failures\n\n**Use Cases:**\n- Passing stdin/stdout/stderr between client and daemon\n- Transferring arbitrary file handles (files, sockets, pipes)\n\nBased on `sendfd` crate but with higher-level API and better ergonomics.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-15T19:55:44.971221163-05:00","created_by":"rektide","updated_at":"2026-01-15T20:10:50.460876403-05:00","dependencies":[{"issue_id":"pfd-9i9","depends_on_id":"pfd-irg","type":"parent-child","created_at":"2026-01-15T19:55:58.587841218-05:00","created_by":"rektide"},{"issue_id":"pfd-9i9","depends_on_id":"pfd-gc3","type":"parent-child","created_at":"2026-01-15T19:57:33.990776336-05:00","created_by":"rektide"}]}
{"id":"pfd-aam","title":"EXECUTION-CONTEXT: Research execution context serialization","description":"Research how to serialize and transfer execution context:\n\n- Context components: command, args, cwd, descriptors\n- Serialization format for socket transfer\n- Working directory handling\n- Argument array management\n- Descriptor mapping and restoration\n- Error handling for invalid contexts\n\nResearch needed:\n- Rust serialization libraries (serde, bincode, etc.)\n- Cross-platform compatibility considerations\n- Security implications of context transfer\n- Validation of execution context\n\nGoal: Design efficient, secure context transfer protocol.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-15T19:55:51.869259921-05:00","created_by":"rektide","updated_at":"2026-01-15T19:55:51.869259921-05:00","dependencies":[{"issue_id":"pfd-aam","depends_on_id":"pfd-irg","type":"parent-child","created_at":"2026-01-15T19:56:00.037267115-05:00","created_by":"rektide"},{"issue_id":"pfd-aam","depends_on_id":"pfd-gc3","type":"parent-child","created_at":"2026-01-15T19:57:35.164850576-05:00","created_by":"rektide"}]}
{"id":"pfd-gc3","title":"Research: Foundation research for prefork system","description":"Foundation research for the entire prefork system. This epic contains all research tickets needed to understand the technologies and patterns we'll use.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-15T19:56:36.330593628-05:00","created_by":"rektide","updated_at":"2026-01-15T19:56:36.330593628-05:00"}
{"id":"pfd-gyj","title":"DAEMON-LIFECYCLE: Research daemonization and process management","description":"Research Rust daemon patterns:\n\n- `fork` crate usage and capabilities\n- Double-fork technique for background processes\n- PID file management in XDG locations\n- Process termination and cleanup\n- Auto-launch daemon on demand (--create/-C option)\n- Daemon health checking via PID files\n\nResearch needed:\n- PID file creation and locking\n- Daemon startup validation\n- Process group management\n- Signal handling for graceful shutdown\n\nGoal: Understand robust daemon lifecycle management.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-15T19:55:49.835983071-05:00","created_by":"rektide","updated_at":"2026-01-15T19:55:49.835983071-05:00","dependencies":[{"issue_id":"pfd-gyj","depends_on_id":"pfd-irg","type":"parent-child","created_at":"2026-01-15T19:55:59.597266579-05:00","created_by":"rektide"},{"issue_id":"pfd-gyj","depends_on_id":"pfd-gc3","type":"parent-child","created_at":"2026-01-15T19:57:34.845329199-05:00","created_by":"rektide"}]}
{"id":"pfd-hq4","title":"SOCKET-DISCOVERY: Research Unix domain socket discovery patterns","description":"Research strategies for locating the daemon socket:\n\n- Local file mode: `./pfd.sock` or `.pfd.sock`\n- XDG runtime mode: `$XDG_RUNTIME_DIR/pfd.sock`\n- XDG-project mode: `$XDG_RUNTIME_DIR/pfd.\u003cproject-name\u003e.sock`\n\nResearch needed:\n- Rust `directories` crate for XDG paths\n- Socket file naming conventions\n- Fallback strategies between modes\n- Socket creation permissions and ownership\n- Atomic operations for socket file management\n\nGoal: Design robust multi-mode discovery system.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-15T19:55:48.506481935-05:00","created_by":"rektide","updated_at":"2026-01-15T19:55:48.506481935-05:00","dependencies":[{"issue_id":"pfd-hq4","depends_on_id":"pfd-irg","type":"parent-child","created_at":"2026-01-15T19:55:59.120229169-05:00","created_by":"rektide"},{"issue_id":"pfd-hq4","depends_on_id":"pfd-gc3","type":"parent-child","created_at":"2026-01-15T19:57:34.450907234-05:00","created_by":"rektide"}]}
{"id":"pfd-irg","title":"prefork-democli: Build pre-fork daemon and client system","description":"A client/server pre-fork system for Rust:\n- `pfd` (daemon): Receives execution contexts and file descriptors, runs commands\n- `pfc` (client): Transfers execution context to daemon and terminates\n\nExecution context includes: command, args, cwd, and file descriptors (stdin/stdout/stderr)\n\nKey features:\n- File descriptor transfer via Unix domain sockets\n- Multiple discovery strategies (local, XDG, XDG-project)\n- Auto-launch daemon on demand\n- Minimal client footprint","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-15T19:54:39.24530666-05:00","created_by":"rektide","updated_at":"2026-01-15T19:57:38.973895509-05:00","closed_at":"2026-01-15T19:57:38.973895509-05:00","close_reason":"Replaced with better structured epics: Research (prefork-rs-gc3), PFD-DAEMON (prefork-rs-ufj), PFC-CLIENT (prefork-rs-ksn)"}
{"id":"pfd-ksn","title":"PFC-CLIENT: Minimal client for execution transfer","description":"PreFork Client (PFC) - minimal lightweight client that transfers execution context to daemon.\n\nPhilosophy: Keep client incredibly small and simple. Find daemon quickly, transfer context, terminate.\n\nResponsibilities:\n- Socket discovery with multiple strategies\n- Auto-launch daemon if not found (--create flag)\n- Serialize execution context\n- Transfer context and file descriptors via socket\n- Minimal error handling and feedback","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-15T19:56:54.737220413-05:00","created_by":"rektide","updated_at":"2026-01-15T19:57:31.346891819-05:00"}
{"id":"pfd-r58","title":"FD-TRANSFER: Crate for file descriptor transfer","description":"Crate library for file descriptor transfer over Unix domain sockets.\n\nThis library provides safe, ergonomic file descriptor passing using ancillary data:\n\n**Capabilities:**\n- Send/receive multiple file descriptors atomically\n- Unix domain socket wrapper with ancillary data support\n- Descriptor lifecycle and ownership management\n- Error handling for partial/failed transfers\n- Zero-copy descriptor passing where possible\n\n**API Goals:**\n- Simple `send_fds(\u0026socket, \u0026[FileDescriptor])` interface\n- `recv_fds(\u0026socket) -\u003e Result\u003cVec\u003cFileDescriptor\u003e\u003e`\n- Atomic transfer guarantees for multiple descriptors\n- Clear error types for debugging transfer failures\n\n**Use Cases:**\n- Passing stdin/stdout/stderr between processes\n- Transferring arbitrary file handles (files, sockets, pipes)\n- Pre-fork daemon patterns where child needs parent's resources\n\nBased on `sendfd` crate research but with higher-level API and better ergonomics.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-15T20:04:41.268913372-05:00","created_by":"rektide","updated_at":"2026-01-15T20:04:41.268913372-05:00"}
{"id":"pfd-ufj","title":"PFD-DAEMON: Server that receives and executes commands","description":"PreFork Daemon (PFD) - the long-running server that receives execution contexts and file descriptors, then executes commands.\n\nResponsibilities:\n- Accept Unix domain socket connections\n- Receive file descriptors via ancillary data\n- Parse and validate execution context\n- Execute commands with provided resources\n- Manage daemon lifecycle (double-fork, PID files)\n- Support auto-launch functionality\n\nInitial command: `add` - sum all arguments, complain on stderr","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-15T19:56:52.727849614-05:00","created_by":"rektide","updated_at":"2026-01-15T19:57:30.908901034-05:00"}
